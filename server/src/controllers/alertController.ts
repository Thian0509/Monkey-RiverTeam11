// src/controllers/alertController.ts
import { Request, Response, NextFunction } from "express"; // Import NextFunction for middleware typing
import Alert, { IAlert } from "../models/Alert";
import mongoose from "mongoose";

// Extend the Request type to include the user object from your auth middleware
// This is crucial for TypeScript to recognize req.user.id
declare module 'express-serve-static-core' {
  interface Request {
    user?: {
      userId: string; // Assuming your auth.ts attaches 'userId' to req.user
      // Add other user properties if available and relevant from your JWT payload
    };
  }
}

// Helper function to format alert for client (consistent naming: _id to id, timestamp to ISO string)
const formatAlertForClient = (alert: IAlert) => {
  const obj = alert.toObject(); // Convert Mongoose document to plain JavaScript object
  return {
    id: (obj._id as mongoose.Types.ObjectId).toString(), // Map _id to id string
    message: obj.message,
    type: obj.type,
    read: obj.read,
    timestamp: obj.timestamp.toISOString(), // Ensure timestamp is an ISO string
    // Omit other fields like _id, __v, userId, createdAt, updatedAt if not needed on client
  };
};

// **1. Get all Alerts/Notifications for the authenticated user**
// Corresponds to client's fetchNotifications
export const getAllAlerts = async (req: Request, res: Response) => {
  try {
    const userId = req.user?.userId; // Get user ID from authenticated request (from auth.ts)

    if (!userId) {
      return res.status(401).json({ message: 'Not authenticated or user ID missing.' });
    }

    const alerts = await Alert.find({ userId: new mongoose.Types.ObjectId(userId) })
      .sort({ timestamp: -1 }); // Sort by newest first

    // Respond with an array of formatted alert objects
    res.status(200).json(alerts.map(formatAlertForClient));
  } catch (error: any) {
    console.error('Error fetching user alerts:', error);
    res.status(500).json({ message: 'Internal server error', error: error.message });
  }
};

// **2. Create a new Alert/Notification for the authenticated user**
// Corresponds to client's addNotification
export const createAlert = async (req: Request, res: Response) => {
  try {
    const { message, type } = req.body;
    const userId = req.user?.userId; // Get user ID from authenticated request

    if (!message || !userId) {
      return res.status(400).json({ message: 'Message and authenticated user ID are required.' });
    }

    const newAlertData: IAlert = {
      message,
      type: type || 'info', // Use provided type or default to 'info'
      timestamp: new Date(), // Set current timestamp
      read: false, // New alerts are unread by default
      userId: new mongoose.Types.ObjectId(userId), // Associate with the current user
    } as IAlert; // Type assertion as _id is auto-generated by Mongoose

    const alert = await Alert.create(newAlertData);

    // Respond with the formatted created alert object
    res.status(201).json(formatAlertForClient(alert));
  } catch (error: any) {
    console.error('Error creating alert:', error);
    res.status(500).json({ message: 'Internal server error', error: error.message });
  }
};

// **3. Mark a specific Alert/Notification as read for the authenticated user**
// Corresponds to client's markAsRead
export const markAlertAsRead = async (req: Request, res: Response) => {
  try {
    const { id } = req.params; // Alert ID (MongoDB _id)
    const userId = req.user?.userId;

    if (!userId) {
      return res.status(401).json({ message: 'Not authenticated or user ID missing.' });
    }

    const alert = await Alert.findOneAndUpdate(
      { _id: id, userId: new mongoose.Types.ObjectId(userId) }, // Find by ID AND userId for security
      { read: true },
      { new: true } // Return the updated document
    );

    if (!alert) {
      return res.status(404).json({ message: 'Alert not found or not authorized to access.' });
    }

    // Respond with the formatted updated alert object
    res.status(200).json(formatAlertForClient(alert));
  } catch (error: any) {
    console.error('Error marking alert as read:', error);
    if (error.name === 'CastError' && error.kind === 'ObjectId') {
      return res.status(400).json({ message: "Invalid alert ID format." });
    }
    res.status(500).json({ message: 'Internal server error', error: error.message });
  }
};

// **4. Mark ALL Alerts/Notifications as read for the authenticated user**
// Corresponds to client's markAllAsRead
export const markAllUserAlertsAsRead = async (req: Request, res: Response) => {
  try {
    const userId = req.user?.userId;

    if (!userId) {
      return res.status(401).json({ message: 'Not authenticated or user ID missing.' });
    }

    await Alert.updateMany(
      { userId: new mongoose.Types.ObjectId(userId), read: false }, // Only unread alerts for this user
      { read: true }
    );

    // Re-fetch all alerts for the user to send the updated list back to the client
    const updatedAlerts = await Alert.find({ userId: new mongoose.Types.ObjectId(userId) })
      .sort({ timestamp: -1 });

    // Respond with an array of formatted updated alert objects
    res.status(200).json(updatedAlerts.map(formatAlertForClient));
  } catch (error: any) {
    console.error('Error marking all alerts as read:', error);
    res.status(500).json({ message: 'Internal server error', error: error.message });
  }
};

// **5. Delete a specific Alert/Notification for the authenticated user**
// Corresponds to client's removeNotification
export const deleteAlert = async (req: Request, res: Response) => { // Renamed from deleteUserAlert to match existing route
  try {
    const { id } = req.params; // Alert ID (MongoDB _id)
    const userId = req.user?.userId;

    if (!userId) {
      return res.status(401).json({ message: 'Not authenticated or user ID missing.' });
    }

    const result = await Alert.findOneAndDelete({ _id: id, userId: new mongoose.Types.ObjectId(userId) }); // Find by ID AND userId

    if (!result) {
      return res.status(404).json({ message: 'Alert not found or not authorized to delete.' });
    }
    // Respond with the ID of the deleted alert for client-side state update
    res.status(200).json({ message: 'Alert deleted successfully', id });
  } catch (error: any) {
    console.error('Error deleting alert:', error);
    if (error.name === 'CastError' && error.kind === 'ObjectId') {
      return res.status(400).json({ message: "Invalid alert ID format." });
    }
    res.status(500).json({ message: 'Internal server error', error: error.message });
  }
};

// Keep getAlertById if you have other uses for it, but it's not directly used by the Notifications page
export const getAlertById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const userId = req.user?.userId; // Ensure it's for the authenticated user

    if (!userId) {
      return res.status(401).json({ message: 'Not authenticated or user ID missing.' });
    }

    const alert = await Alert.findOne({ _id: id, userId: new mongoose.Types.ObjectId(userId) });
    if (!alert) {
      return res.status(404).json({ message: "Alert not found or not authorized" });
    }
    res.status(200).json(formatAlertForClient(alert));
  } catch (error: any) {
    console.error("Error fetching alert:", error);
    if (error.name === 'CastError' && error.kind === 'ObjectId') {
        return res.status(400).json({ message: "Invalid alert ID format." });
    }
    res.status(500).json({ message: "Internal server error", error: error.message });
  }
};